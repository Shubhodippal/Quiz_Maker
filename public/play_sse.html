<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Join Quiz (SSE)</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#0f172a; --ink:#e5e7eb; --muted:#94a3b8;
      --border:#1f2937; --accent:#16a34a; --accent-ink:#062b12; --primary:#2563eb;
      --danger:#ef4444; --warn:#f59e0b; --success:#16a34a;
    }
    /* layout */
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink);margin:0}
    .wrap{max-width:960px;margin:24px auto;padding:16px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    h1,h2,h3{margin:0 0 12px 0}
    .muted{color:var(--muted)}
    /* inputs/buttons */
    input{padding:12px;border-radius:12px;border:1px solid var(--border);background:#0b1426;color:var(--ink)}
    input:focus{outline:2px solid #3352d1;border-color:#3352d1}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .btn{padding:12px 16px;border-radius:12px;border:0;cursor:pointer;color:#fff;background:var(--accent)}
    .btn.primary{background:var(--primary)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    /* option cards */
    .opts{display:grid;gap:12px;margin-top:10px}
    .opt{
      position:relative;background:#0c152b;border:1px solid var(--border);
      border-radius:14px;padding:14px 16px;cursor:pointer;transition:transform .05s ease, border-color .15s ease, background .15s ease;
      user-select:none;
    }
    .opt:hover{transform:translateY(-1px);border-color:#284e9e}
    .opt.disabled{opacity:.55;pointer-events:none}
    .opt .bullet{
      width:18px;height:18px;border-radius:50%;border:2px solid #2a3a64;display:inline-flex;align-items:center;justify-content:center;margin-right:10px;flex:0 0 18px;
    }
    .opt .text{flex:1}
    .opt.picked{border-color:var(--accent);background:#0d1f16}
    .opt.picked .bullet{border-color:var(--accent);background:var(--accent)}
    .opt.correct{outline:2px solid var(--accent)}
    .opt.incorrect{outline:2px solid var(--danger)}
    .opt-row{display:flex;align-items:center;gap:10px}
    /* header/status */
    .header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0b1526;border:1px solid var(--border);color:var(--muted);font-size:13px}
    .progress{position:relative;height:8px;background:#0b1526;border:1px solid var(--border);border-radius:999px;overflow:hidden;margin-top:10px}
    .bar{position:absolute;left:0;top:0;bottom:0;width:0%;background:linear-gradient(90deg,#3b82f6,#22c55e)}
    /* toast */
    .toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#111827;color:#e5e7eb;border:1px solid var(--border);border-radius:12px;padding:10px 14px;opacity:0;pointer-events:none;transition:opacity .2s ease}
    .toast.show{opacity:1}
    .toast.success{background:#0f2815;border-color:var(--success);color:var(--success)}
    .toast.error{background:#2d1b1b;border-color:var(--danger);color:var(--danger)}
    /* connection status */
    .status-indicator{display:inline-flex;align-items:center;gap:6px}
    .status-dot{width:8px;height:8px;border-radius:50%;background:var(--muted)}
    .status-dot.connected{background:var(--success)}
    .status-dot.connecting{background:var(--warn);animation:pulse 1s infinite}
    .status-dot.disconnected{background:var(--danger)}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}
    /* responsive option grid */
    @media (min-width:680px){ .opts{grid-template-columns:1fr 1fr} }
    /* session restoration banner */
    .session-banner{background:#0d1f16;border:1px solid var(--success);border-radius:12px;padding:12px;margin-bottom:16px;display:flex;align-items:center;gap:12px}
    .session-banner .icon{color:var(--success);font-size:18px}
    
    /* Fullscreen optimizations */
    :fullscreen {
      background: var(--bg);
    }
    :-webkit-full-screen {
      background: var(--bg);
    }
    :-moz-full-screen {
      background: var(--bg);
    }
    :-ms-fullscreen {
      background: var(--bg);
    }
    
    /* Better spacing in fullscreen */
    :fullscreen .wrap {
      max-width: none;
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 2rem;
    }
    
    :fullscreen .card {
      max-width: 800px;
      margin: 0 auto;
    }
    
    /* Larger question text in fullscreen */
    :fullscreen h2 {
      font-size: 2rem;
      line-height: 1.3;
    }
    
    /* Better option layout in fullscreen */
    :fullscreen .opts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 16px;
      margin-top: 2rem;
    }
    
    :fullscreen .opt {
      padding: 20px 24px;
      font-size: 1.1rem;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="register">
      <h1>ðŸŽ¯ Join the Quiz (SSE)</h1>
      <p class="muted">Room code: <span id="room"></span></p>
      <div class="row" style="margin:10px 0 12px">
        <input type="text" id="name" placeholder="Your name *" maxlength="50" required />
        <input type="email" id="email" placeholder="Email address *" maxlength="100" required />
        <input type="tel" id="phone" placeholder="Phone number *" maxlength="20" required />
      </div>
      <button class="btn primary" id="join">Join Room</button>
      <p class="muted" style="margin-top:12px;font-size:13px;">
        * All fields are required to join the quiz<br>
        Using Server-Sent Events for better mobile connectivity
      </p>
    </div>

    <div class="card" id="game" style="display:none;">
      <div id="sessionBanner" class="session-banner" style="display:none;">
        <span class="icon">ðŸ”„</span>
        <div>
          <strong>Session Restored</strong>
          <div class="muted" style="font-size:12px;">Your previous session was automatically restored</div>
        </div>
      </div>

      <div class="header">
        <div class="status-indicator">
          <span class="status-dot" id="statusDot"></span>
          <span id="statusText">Connecting...</span>
        </div>
        <div class="badge">
          <span id="playerName">Player</span> â€¢ <span id="playerId">------</span>
        </div>
      </div>

      <h2 id="qtext">Waiting for next questionâ€¦</h2>
      <div class="progress"><div class="bar" id="pbar"></div></div>

      <div class="opts" id="opts"></div>

      <div class="muted" id="note" style="margin-top:10px;">Pick one option before time's up. You'll see what you chose highlighted.</div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  const params = new URLSearchParams(location.search);
  const code = params.get('room');
  document.getElementById('room').textContent = code || 'â€”';

  // Persistent storage keys
  const STORAGE_KEYS = {
    player: `quiz_player_${code}`,
    session: `quiz_session_${code}`
  };

  // state
  let player = null;
  let eventSource = null;
  let reconnectAttempts = 0;
  const maxReconnectAttempts = 5;
  let chosenId = null;
  let deadline = 0;
  let timer = null;

  // elements
  const $reg = document.getElementById('register');
  const $game = document.getElementById('game');
  const $sessionBanner = document.getElementById('sessionBanner');
  const $playerName = document.getElementById('playerName');
  const $playerId = document.getElementById('playerId');
  const $statusText = document.getElementById('statusText');
  const $statusDot = document.getElementById('statusDot');
  const $qtext = document.getElementById('qtext');
  const $opts = document.getElementById('opts');
  const $pbar = document.getElementById('pbar');
  const $note = document.getElementById('note');
  const $toast = document.getElementById('toast');

  // Check for existing session on page load
  function checkExistingSession() {
    try {
      const savedPlayer = localStorage.getItem(STORAGE_KEYS.player);
      const savedSession = localStorage.getItem(STORAGE_KEYS.session);
      
      if (savedPlayer && savedSession) {
        player = JSON.parse(savedPlayer);
        const sessionData = JSON.parse(savedSession);
        
        showGameInterface(true);
        connectSSE();
        return true;
      }
    } catch (error) {
      console.warn('Failed to restore session:', error);
      clearStoredSession();
    }
    return false;
  }

  function saveSession(playerData) {
    try {
      playerData.room_code = code;
      localStorage.setItem(STORAGE_KEYS.player, JSON.stringify(playerData));
      localStorage.setItem(STORAGE_KEYS.session, JSON.stringify({
        timestamp: Date.now(),
        room_code: code
      }));
    } catch (error) {
      console.warn('Failed to save session:', error);
    }
  }

  function clearStoredSession() {
    try {
      localStorage.removeItem(STORAGE_KEYS.player);
      localStorage.removeItem(STORAGE_KEYS.session);
    } catch (error) {
      console.warn('Failed to clear session:', error);
    }
  }

  function showGameInterface(isRestore = false) {
    $reg.style.display = 'none';
    $game.style.display = 'block';
    $playerName.textContent = player.name || 'Player';
    $playerId.textContent = (player.id || '').slice(0, 6);
    
    if (isRestore) {
      $sessionBanner.style.display = 'flex';
      setTimeout(() => $sessionBanner.style.display = 'none', 5000);
    }
  }

  function updateConnectionStatus(status) {
    const statusMap = {
      connected: { text: 'Connected', class: 'connected' },
      connecting: { text: 'Connecting...', class: 'connecting' },
      disconnected: { text: 'Disconnected', class: 'disconnected' },
      waiting: { text: 'Waiting for quiz...', class: 'connected' }
    };
    
    const config = statusMap[status] || statusMap.waiting;
    $statusText.textContent = config.text;
    $statusDot.className = `status-dot ${config.class}`;
  }

  function toast(msg, ms = 1400, type = 'info') {
    $toast.textContent = msg;
    $toast.className = `toast ${type}`;
    $toast.classList.add('show');
    setTimeout(() => $toast.classList.remove('show'), ms);
  }

  function setDisabled(dis) {
    document.querySelectorAll('.opt').forEach(el => {
      if (dis) el.classList.add('disabled'); else el.classList.remove('disabled');
    });
  }

  function percentageLeft() {
    const total = Math.max(0, deadline - (deadline - 25_000)); // 25s window
    const remain = Math.max(0, deadline - Date.now());
    return total ? Math.max(0, Math.min(100, Math.round((remain / 25_000) * 100))) : 0;
  }

  function startCountdown(dl) {
    stopCountdown();
    deadline = dl;
    tick(); // initial
    timer = setInterval(tick, 150);
    function tick() {
      const pct = percentageLeft();
      $pbar.style.width = pct + '%';
      if (pct <= 0) {
        stopCountdown();
        setDisabled(true);
        $note.textContent = 'Time up! Waiting for results...';
      }
    }
  }

  function stopCountdown() {
    if (timer) { clearInterval(timer); timer = null; }
  }

  function clearOptions() {
    $opts.innerHTML = '';
    chosenId = null;
    setDisabled(false);
  }

  function renderQuestion(q, dl) {
    clearOptions();
    if (!q) {
      $qtext.textContent = 'Quiz completed! Thanks for playing.';
      return;
    }
    $qtext.textContent = q.text;
    $note.textContent = 'Tap once to choose. You can\'t change after submitting.';
    (q.options || []).forEach((o, idx) => {
      const div = document.createElement('div');
      div.className = 'opt';
      div.innerHTML = `
        <div class="opt-row">
          <div class="bullet"></div>
          <div class="text">${o.text}</div>
        </div>
      `;
      div.addEventListener('click', () => handleOptionClick(o.id, div));
      $opts.appendChild(div);
    });
    if (dl) startCountdown(dl);
  }

  function markPicked(id) {
    document.querySelectorAll('.opt').forEach(el => {
      el.classList.remove('picked');
    });
    // Find and mark the picked option
    document.querySelectorAll('.opt').forEach((el, idx) => {
      if (el.dataset.optionId === id) {
        el.classList.add('picked');
      }
    });
  }

  async function handleOptionClick(optionId, element) {
    if (chosenId || !player) return;
    
    chosenId = optionId;
    element.classList.add('picked');
    element.dataset.optionId = optionId;
    setDisabled(true);
    
    try {
      const response = await fetch(`/api/room/${code}/answer`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          playerId: player.id,
          optionId: optionId
        })
      });
      
      const result = await response.json();
      
      if (response.ok && result.type === 'accepted') {
        toast('Answer submitted!', 1500, 'success');
        $note.textContent = 'Answer submitted! Waiting for results...';
      } else {
        toast(result.message || 'Failed to submit answer', 2500, 'error');
        setDisabled(false);
        chosenId = null;
        element.classList.remove('picked');
      }
    } catch (error) {
      console.error('Answer submission failed:', error);
      toast('Connection error. Please try again.', 2500, 'error');
      setDisabled(false);
      chosenId = null;
      element.classList.remove('picked');
    }
  }

  async function join() {
    const name = document.getElementById('name').value.trim();
    const email = document.getElementById('email').value.trim();
    const phone = document.getElementById('phone').value.trim();

    const body = { name, email, phone };
    
    // Validate all required fields
    if (!body.name) {
      toast('Please enter your name', 2000, 'error');
      document.getElementById('name').focus();
      return;
    }
    
    if (!body.email) {
      toast('Please enter your email address', 2000, 'error');
      document.getElementById('email').focus();
      return;
    }
    
    // Basic email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(body.email)) {
      toast('Please enter a valid email address', 2000, 'error');
      document.getElementById('email').focus();
      return;
    }
    
    if (!body.phone) {
      toast('Please enter your phone number', 2000, 'error');
      document.getElementById('phone').focus();
      return;
    }
    
    // Basic phone validation (at least 10 digits)
    const phoneDigits = body.phone.replace(/\D/g, '');
    if (phoneDigits.length < 10) {
      toast('Please enter a valid phone number (at least 10 digits)', 2000, 'error');
      document.getElementById('phone').focus();
      return;
    }

    const joinBtn = document.getElementById('join');
    joinBtn.disabled = true;
    joinBtn.textContent = 'Joining...';

    try {
      const response = await fetch(`/api/room/${code}/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.error || `Registration failed (${response.status})`;
        throw new Error(errorMessage);
      }

      player = await response.json();
      saveSession(player);
      showGameInterface();
      connectSSE();
      toast('Successfully joined the quiz!', 2000, 'success');
    } catch (error) {
      toast(`${error.message}`, 3000, 'error');
    } finally {
      joinBtn.disabled = false;
      joinBtn.textContent = 'Join Room';
    }
  }

  function connectSSE() {
    if (!player) return;
    
    updateConnectionStatus('connecting');
    
    // Close existing connection
    if (eventSource) {
      eventSource.close();
    }
    
    const sseUrl = `/stream/${code}?playerId=${player.id}`;
    eventSource = new EventSource(sseUrl);
    
    eventSource.onopen = () => {
      updateConnectionStatus('connected');
      reconnectAttempts = 0;
    };
    
    eventSource.addEventListener('connected', (event) => {
      const data = JSON.parse(event.data);
      console.log('SSE connected:', data);
      updateConnectionStatus('waiting');
    });
    
    eventSource.addEventListener('question', (event) => {
      const data = JSON.parse(event.data);
      renderQuestion(data.question, data.deadline);
    });
    
    eventSource.addEventListener('result', (event) => {
      const data = JSON.parse(event.data);
      handleResult(data);
    });
    
    eventSource.addEventListener('presence', (event) => {
      const data = JSON.parse(event.data);
      console.log('Presence update:', data.count);
    });
    
    eventSource.onerror = (event) => {
      updateConnectionStatus('disconnected');
      console.error('SSE error:', event);
      
      // Auto-reconnect with exponential backoff
      if (reconnectAttempts < maxReconnectAttempts) {
        const delay = Math.pow(2, reconnectAttempts) * 1000;
        setTimeout(() => {
          reconnectAttempts++;
          connectSSE();
        }, delay);
      } else {
        toast('Connection lost. Please refresh the page.', 5000, 'error');
      }
    };
  }

  function handleResult(data) {
    stopCountdown();
    setDisabled(true);
    
    // Players only receive the correct answer ID - no scores or leaderboards
    // Show correct/incorrect for chosen answer
    if (chosenId && data.correct_option_id) {
      document.querySelectorAll('.opt').forEach(el => {
        if (el.dataset.optionId === chosenId) {
          if (chosenId === data.correct_option_id) {
            el.classList.add('correct');
            toast('Correct! ðŸŽ‰', 2000, 'success');
          } else {
            el.classList.add('incorrect');
            toast('Incorrect answer', 2000, 'error');
          }
        }
        // Also highlight the correct answer for learning
        if (el.dataset.optionId === data.correct_option_id) {
          el.style.outline = '2px solid var(--success)';
          el.style.backgroundColor = 'rgba(22, 163, 74, 0.1)';
        }
      });
    }
    
    $note.textContent = 'Results received. Waiting for next question...';
    
    // Clear after a few seconds
    setTimeout(() => {
      clearOptions();
      $qtext.textContent = 'Waiting for next questionâ€¦';
      $note.textContent = 'Pick one option before time\'s up.';
    }, 4000);
  }

  // Wire up join button
  document.getElementById('join').addEventListener('click', join);

  // Allow Enter key to join
  ['name', 'email', 'phone'].forEach(id => {
    document.getElementById(id).addEventListener('keypress', (e) => {
      if (e.key === 'Enter') join();
    });
  });

  // Handle page visibility changes (user switches tabs/apps)
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && player && (!eventSource || eventSource.readyState === EventSource.CLOSED)) {
      connectSSE();
    }
  });

  // Handle page unload (save state)
  window.addEventListener('beforeunload', () => {
    if (player) {
      saveSession(player);
    }
    if (eventSource) {
      eventSource.close();
    }
  });

  // Fullscreen functionality
  function enterFullscreen() {
    const elem = document.documentElement;
    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.mozRequestFullScreen) { // Firefox
      elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen) { // Chrome, Safari and Opera
      elem.webkitRequestFullscreen();
    } else if (elem.msRequestFullscreen) { // IE/Edge
      elem.msRequestFullscreen();
    }
  }

  function exitFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) { // Firefox
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) { // Chrome, Safari and Opera
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE/Edge
      document.msExitFullscreen();
    }
  }

  // Auto-enter fullscreen when game starts
  function autoEnterFullscreen() {
    // Only enter fullscreen if not already in fullscreen
    if (!document.fullscreenElement && !document.mozFullScreenElement && 
        !document.webkitFullscreenElement && !document.msFullscreenElement) {
      
      // Request fullscreen with user interaction
      enterFullscreen().catch(err => {
        console.log('Could not enter fullscreen automatically:', err);
        // Show a toast message suggesting manual fullscreen
        toast('Tip: Press F11 for better gaming experience!', 3000, 'info');
      });
    }
  }

  // Override showGameInterface to trigger fullscreen
  const originalShowGameInterface = showGameInterface;
  showGameInterface = function(isRestore = false) {
    originalShowGameInterface(isRestore);
    
    // Enter fullscreen when game interface is shown
    setTimeout(() => {
      autoEnterFullscreen();
    }, 100); // Small delay to ensure UI is ready
  };

  // Initialize - check for existing session
  if (code) {
    if (!checkExistingSession()) {
      updateConnectionStatus('waiting');
    }
  } else {
    // No room code provided
    document.getElementById('room').textContent = 'No room code provided';
    document.getElementById('join').disabled = true;
    toast('Invalid room code. Please check your link.', 5000, 'error');
  }
})();
</script>
</body>
</html>
