{
  "version": 3,
  "sources": ["../../../src/index.ts", "file:///C:/Users/palsh/AppData/Roaming/npm/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "file:///C:/Users/palsh/AppData/Roaming/npm/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-nOvJ93/middleware-insertion-facade.js", "file:///C:/Users/palsh/AppData/Roaming/npm/node_modules/wrangler/templates/middleware/common.ts", "../bundle-nOvJ93/middleware-loader.entry.ts"],
  "sourceRoot": "E:\\Projects\\cloudflare-realtime-quiz\\.wrangler\\tmp\\dev-S9yA4m",
  "sourcesContent": ["export interface Env {\n  DB: D1Database;\n  ROOM: DurableObjectNamespace;\n}\n\ntype QuizOption = { id: string; text: string };\ntype QuizQuestion = {\n  id: string;                  // stored as ROOM:qId\n  text: string;\n  correct_option_id?: string;  // stored as ROOM:qId:oId (fallback handled)\n  options: QuizOption[];       // option ids are ROOM:qId:oId\n  position?: number;\n};\n\nfunction json(data: any, init: ResponseInit = {}) {\n  return new Response(JSON.stringify(data), {\n    ...init,\n    headers: { \"content-type\": \"application/json\", ...(init.headers || {}) },\n  });\n}\n\nfunction generateCode() {\n  const chars = \"ABCDEFGHJKMNPQRSTUVWXYZ23456789\";\n  let out = \"\";\n  for (let i = 0; i < 5; i++) out += chars[Math.floor(Math.random() * chars.length)];\n  return out;\n}\n\n/** --- Scoring config ---\n * Rank-based points rewarding the fastest correct answers.\n * 1st: 5, 2nd: 4, 3rd: 3, 4th: 2, 5th: 1, all other correct: +1\n */\nconst RANK_POINTS = [5, 4, 3, 2, 1];\nconst MIN_POINTS_FOR_CORRECT = 1;\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n\n    // Create room with questions\n    if (url.pathname === \"/api/room\" && request.method === \"POST\") {\n      const raw: Array<{\n        id: string;\n        text: string;\n        correct_option_id?: string;\n        options: { id: string; text: string }[];\n      }> = await request.json();\n\n      const code = generateCode();\n      await env.DB.prepare(\"INSERT INTO rooms (code, created_at) VALUES (?, ?)\")\n        .bind(code, Date.now())\n        .run();\n\n      // Insert questions/options with prefixed IDs (avoid collisions)\n      let pos = 0;\n      for (const q of raw) {\n        const qid = `${code}:${q.id}`;\n        const correctId = q.correct_option_id ? `${qid}:${q.correct_option_id}` : null;\n\n        await env.DB.prepare(\n          \"INSERT INTO questions (id, room_code, text, correct_option_id, position) VALUES (?, ?, ?, ?, ?)\"\n        )\n          .bind(qid, code, q.text, correctId, pos++)\n          .run();\n\n        for (const o of q.options || []) {\n          const oid = `${qid}:${o.id}`;\n          await env.DB.prepare(\"INSERT INTO options (id, question_id, text) VALUES (?, ?, ?)\")\n            .bind(oid, qid, o.text)\n            .run();\n        }\n      }\n\n      // Warm up DO\n      const id = env.ROOM.idFromName(code);\n      await env.ROOM.get(id).fetch(\"https://do/bootstrap?code=\" + code);\n\n      return json({ code });\n    }\n\n    // Register player\n    const reg = url.pathname.match(/^\\/api\\/room\\/([A-Z0-9]{5})\\/register$/);\n    if (reg && request.method === \"POST\") {\n      const code = reg[1];\n      const body = (await request.json()) as { name?: string; email?: string; phone?: string };\n      \n      // Validate required fields\n      if (!body.name || body.name.trim().length === 0) {\n        return json({ error: \"Name is required\" }, { status: 400 });\n      }\n      \n      if (!body.email || body.email.trim().length === 0) {\n        return json({ error: \"Email is required\" }, { status: 400 });\n      }\n      \n      // Basic email validation\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(body.email.trim())) {\n        return json({ error: \"Please provide a valid email address\" }, { status: 400 });\n      }\n      \n      if (!body.phone || body.phone.trim().length === 0) {\n        return json({ error: \"Phone number is required\" }, { status: 400 });\n      }\n      \n      // Basic phone validation (at least 10 digits)\n      const phoneDigits = body.phone.trim().replace(/\\D/g, '');\n      if (phoneDigits.length < 10) {\n        return json({ error: \"Please provide a valid phone number with at least 10 digits\" }, { status: 400 });\n      }\n      \n      const pid = crypto.randomUUID();\n      const name = body.name.trim();\n      const email = body.email.trim().toLowerCase();\n      const phone = body.phone.trim();\n      \n      await env.DB.prepare(\n        \"INSERT INTO players (id, room_code, name, email, phone, score) VALUES (?, ?, ?, ?, ?, 0)\"\n      )\n        .bind(pid, code, name, email, phone)\n        .run();\n      return json({ id: pid, name, email, phone });\n    }\n\n    // Participants list (admin panel)\n    const plist = url.pathname.match(/^\\/api\\/room\\/([A-Z0-9]{5})\\/participants$/);\n    if (plist && request.method === \"GET\") {\n      const code = plist[1];\n      const limit = Math.min(parseInt(url.searchParams.get(\"limit\") || \"250\", 10), 250);\n      const offset = Math.max(parseInt(url.searchParams.get(\"offset\") || \"0\", 10), 0);\n      const totalRow = await env.DB.prepare(\n        \"SELECT COUNT(*) AS c FROM players WHERE room_code = ?\"\n      ).bind(code).first<any>();\n      const { results } = await env.DB.prepare(\n        \"SELECT id, name, email, phone, score FROM players WHERE room_code = ? ORDER BY name COLLATE NOCASE LIMIT ? OFFSET ?\"\n      ).bind(code, limit, offset).all();\n      return json({ total: totalRow?.c || 0, items: results || [] });\n    }\n\n    // Top 5 winners\n    const win = url.pathname.match(/^\\/api\\/room\\/([A-Z0-9]{5})\\/winners$/);\n    if (win && request.method === \"GET\") {\n      const code = win[1];\n      const { results } = await env.DB.prepare(\n        \"SELECT id, name, email, phone, score FROM players WHERE room_code = ? ORDER BY score DESC, id LIMIT 5\"\n      ).bind(code).all();\n      return json(results || []);\n    }\n\n    // Get all questions for admin preview\n    const questions = url.pathname.match(/^\\/api\\/room\\/([A-Z0-9]{5})\\/questions$/);\n    if (questions && request.method === \"GET\") {\n      const code = questions[1];\n      try {\n        const { results: questionResults } = await env.DB.prepare(\n          \"SELECT q.id, q.text, q.correct_option_id, q.position FROM questions q WHERE q.room_code = ? ORDER BY position ASC\"\n        ).bind(code).all();\n\n        const questionsWithOptions = await Promise.all(\n          (questionResults || []).map(async (q: any) => {\n            const { results: optionResults } = await env.DB.prepare(\n              \"SELECT id, text FROM options WHERE question_id = ? ORDER BY id\"\n            ).bind(q.id).all();\n\n            return {\n              id: q.id,\n              text: q.text,\n              correct_option_id: q.correct_option_id,\n              position: q.position,\n              options: optionResults || []\n            };\n          })\n        );\n\n        return json(questionsWithOptions);\n      } catch (error) {\n        console.error(\"Error fetching questions:\", error);\n        return json({ error: \"Failed to fetch questions\" }, { status: 500 });\n      }\n    }\n\n    // Admin Next -> DO decides and broadcasts\n    const next = url.pathname.match(/^\\/api\\/room\\/([A-Z0-9]{5})\\/next$/);\n    if (next && request.method === \"POST\") {\n      const code = next[1];\n      const id = env.ROOM.idFromName(code);\n      return env.ROOM.get(id).fetch(\"https://do/next\", { method: \"POST\" });\n    }\n\n    // SSE Stream endpoint for real-time updates\n    const stream = url.pathname.match(/^\\/stream\\/([A-Z0-9]{5})$/);\n    if (stream && request.method === \"GET\") {\n      const code = stream[1];\n      const id = env.ROOM.idFromName(code);\n      \n      // Forward to Durable Object with SSE-specific path\n      const sseRequest = new Request(\"https://do/stream\", {\n        headers: {\n          ...request.headers,\n          \"Accept\": \"text/event-stream\"\n        }\n      });\n      return env.ROOM.get(id).fetch(sseRequest);\n    }\n\n    // Answer submission endpoint (HTTP POST)\n    const answerSubmit = url.pathname.match(/^\\/api\\/room\\/([A-Z0-9]{5})\\/answer$/);\n    if (answerSubmit && request.method === \"POST\") {\n      const code = answerSubmit[1];\n      const id = env.ROOM.idFromName(code);\n      return env.ROOM.get(id).fetch(\"https://do/answer\", { \n        method: \"POST\", \n        body: await request.text(),\n        headers: { \"Content-Type\": \"application/json\" }\n      });\n    }\n\n    // Admin stream endpoint\n    const adminStream = url.pathname.match(/^\\/admin\\/stream\\/([A-Z0-9]{5})$/);\n    if (adminStream && request.method === \"GET\") {\n      const code = adminStream[1];\n      const id = env.ROOM.idFromName(code);\n      \n      const adminRequest = new Request(\"https://do/admin/stream\", {\n        headers: {\n          ...request.headers,\n          \"Accept\": \"text/event-stream\"\n        }\n      });\n      return env.ROOM.get(id).fetch(adminRequest);\n    }\n\n    // WebSocket fallback for legacy support\n    const ws = url.pathname.match(/^\\/ws\\/([A-Z0-9]{5})$/);\n    if (ws && request.headers.get(\"Upgrade\") === \"websocket\") {\n      const code = ws[1];\n      const id = env.ROOM.idFromName(code);\n      return env.ROOM.get(id).fetch(request);\n    }\n\n    return new Response(\"Not found\", { status: 404 });\n  },\n};\n\ntype Client = { \n  ws?: WebSocket; \n  playerId?: string; \n  isAdmin?: boolean;\n  // SSE-specific properties\n  isSSE?: boolean;\n  lastEventId?: string;\n  controller?: ReadableStreamDefaultController;\n};\n\ntype SSEConnection = {\n  controller: ReadableStreamDefaultController;\n  playerId?: string;\n  isAdmin?: boolean;\n  lastEventId: string;\n  connectedAt: number;\n};\n\nexport class Room {\n  state: DurableObjectState;\n  env: Env;\n\n  code = \"\";\n  clients: Set<Client> = new Set();\n  sseConnections: Set<SSEConnection> = new Set();\n  present: Map<string, { name: string; email: string }> = new Map();\n  \n  // Connection management for high load\n  maxConnections = 1000; // Increased limit for scalability\n  connectionCounter = 0;\n  lastCleanup = 0;\n  \n  // Rate limiting for answer submissions\n  answerAttempts: Map<string, number> = new Map(); // playerId -> attempts count\n  lastAnswerReset = 0;\n\n  currentIndex = -1;\n  currentQuestionId: string | null = null; // prefixed id\n  currentStartMs = 0;\n  collecting = false;\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.state = state;\n    this.env = env;\n\n    this.state.blockConcurrencyWhile(async () => {\n      const data = await this.state.storage.get<any>(\"room\");\n      if (data) {\n        this.code = data.code;\n        this.currentIndex = data.currentIndex ?? -1;\n        this.currentQuestionId = data.currentQuestionId ?? null;\n        this.currentStartMs = data.currentStartMs ?? 0;\n        this.collecting = !!data.collecting;\n      }\n    });\n  }\n\n  async fetch(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n\n    // Bootstrap\n    if (url.pathname === \"/bootstrap\") {\n      this.code = url.searchParams.get(\"code\") || this.code;\n      await this.persist();\n      return new Response(\"ok\");\n    }\n\n    // Admin \"next\" \u2014 start 25s window and broadcast with enhanced error handling\n    if (url.pathname === \"/next\" && request.method === \"POST\") {\n      try {\n        const q = await this.loadNextQuestion();\n        if (!q) {\n          return json({ error: \"No more questions\" });\n        }\n\n        this.currentQuestionId = q.id;\n        this.currentStartMs = Date.now();\n        this.collecting = true;\n\n        // Reset rate limiting for new question\n        this.answerAttempts.clear();\n        this.lastAnswerReset = Date.now();\n\n        // Set alarm for 25 seconds\n        await this.state.storage.setAlarm(new Date(this.currentStartMs + 25_000));\n\n        // Broadcast question with error handling\n        const broadcastSuccess = this.broadcast({ \n          type: \"question\", \n          question: q, \n          deadline: this.currentStartMs + 25_000,\n          totalConnections: this.clients.size + this.sseConnections.size\n        });\n        \n        await this.persist();\n        return json({ \n          ok: true, \n          questionId: q.id, \n          connectedClients: this.clients.size + this.sseConnections.size,\n          deadline: this.currentStartMs + 25_000\n        });\n      } catch (error) {\n        console.error(\"Error in next question:\", error);\n        return json({ error: \"Failed to load next question\" }, { status: 500 });\n      }\n    }\n\n    // SSE Stream endpoint\n    if (url.pathname === \"/stream\" && request.headers.get(\"Accept\")?.includes(\"text/event-stream\")) {\n      return this.handleSSEConnection(request, false);\n    }\n\n    // Admin SSE Stream endpoint\n    if (url.pathname === \"/admin/stream\" && request.headers.get(\"Accept\")?.includes(\"text/event-stream\")) {\n      return this.handleSSEConnection(request, true);\n    }\n\n    // Answer submission (HTTP POST)\n    if (url.pathname === \"/answer\" && request.method === \"POST\") {\n      return this.handleAnswerSubmission(request);\n    }\n\n    // WebSocket\n    if (request.headers.get(\"Upgrade\") === \"websocket\") {\n      const pair = new WebSocketPair();\n      const [client, server] = Object.values(pair) as [WebSocket, WebSocket];\n      this.handleSession(server);\n      return new Response(null, { status: 101, webSocket: client });\n    }\n\n    return new Response(\"Not found\", { status: 404 });\n  }\n\n  handleSession(ws: WebSocket) {\n    // Connection limit protection\n    if (this.clients.size >= this.maxConnections) {\n      ws.close(1013, \"Server overloaded\");\n      return;\n    }\n\n    const client: Client = { ws };\n    ws.accept();\n    this.clients.add(client);\n    this.connectionCounter++;\n\n    // Periodic cleanup of stale connections\n    if (Date.now() - this.lastCleanup > 60000) { // Every minute\n      this.cleanupStaleConnections();\n      this.lastCleanup = Date.now();\n    }\n\n    ws.addEventListener(\"message\", async (ev) => {\n      try {\n        const data = JSON.parse(ev.data as string);\n        if (data.type === \"register\") {\n          client.playerId = data.playerId;\n          client.isAdmin = !!data.isAdmin;\n\n          // If player identity provided, track presence\n          if (data.player && data.player.id && !client.isAdmin) {\n            this.present.set(data.player.id, {\n              name: data.player.name || \"Player\",\n              email: data.player.email || \"\",\n            });\n            this.broadcast({ type: \"presence\", count: this.present.size });\n          }\n          ws.send(JSON.stringify({ type: \"registered\", ok: true }));\n        } else if (data.type === \"answer\") {\n          // Enhanced rate limiting for answer submissions\n          if (!this.collecting || !this.currentQuestionId) {\n            ws.send(JSON.stringify({ type: \"error\", message: \"Answer window closed.\" }));\n            return;\n          }\n          if (!data.playerId || !data.optionId) {\n            ws.send(JSON.stringify({ type: \"error\", message: \"Invalid answer data.\" }));\n            return;\n          }\n          \n          // Rate limiting: max 3 attempts per player per question\n          const attempts = this.answerAttempts.get(data.playerId) || 0;\n          if (attempts >= 3) {\n            ws.send(JSON.stringify({ type: \"error\", message: \"Too many answer attempts.\" }));\n            return;\n          }\n          \n          this.answerAttempts.set(data.playerId, attempts + 1);\n          \n          // Check for duplicate answers first (faster than database insert)\n          const already = await this.hasAnswered(this.currentQuestionId, data.playerId);\n          if (already) {\n            ws.send(JSON.stringify({ type: \"error\", message: \"You have already answered this question.\" }));\n            return;\n          }\n          \n          // Store answer with error handling\n          try {\n            await this.storeAnswer(this.currentQuestionId, data.playerId, data.optionId);\n            ws.send(JSON.stringify({ type: \"accepted\", at: Date.now() }));\n          } catch (error) {\n            console.error(\"Answer storage failed:\", error);\n            ws.send(JSON.stringify({ type: \"error\", message: \"Failed to submit answer. Please try again.\" }));\n          }\n        } else if (data.type === \"ping\") {\n          // Heartbeat to keep connection alive\n          ws.send(JSON.stringify({ type: \"pong\" }));\n        }\n      } catch (e: any) {\n        console.error(\"WebSocket message error:\", e);\n        try { \n          ws.send(JSON.stringify({ type: \"error\", message: \"Invalid message format\" })); \n        } catch (sendError) {\n          console.error(\"Failed to send error message:\", sendError);\n        }\n      }\n    });\n\n    ws.addEventListener(\"close\", () => {\n      if (client.playerId && this.present.has(client.playerId)) {\n        this.present.delete(client.playerId);\n        this.broadcast({ type: \"presence\", count: this.present.size });\n      }\n      this.clients.delete(client);\n    });\n\n    ws.addEventListener(\"error\", (error) => {\n      console.error(\"WebSocket error for client:\", error);\n      this.clients.delete(client);\n    });\n  }\n\n  // SSE Connection Handler\n  handleSSEConnection(request: Request, isAdmin: boolean): Response {\n    // Connection limit protection\n    if (this.sseConnections.size >= this.maxConnections) {\n      return new Response(\"Server overloaded\", { status: 503 });\n    }\n\n    const url = new URL(request.url);\n    const lastEventId = request.headers.get(\"Last-Event-ID\") || url.searchParams.get(\"lastEventId\") || \"0\";\n    const playerId = url.searchParams.get(\"playerId\");\n\n    let connectionClosed = false;\n\n    const stream = new ReadableStream({\n      start: async (controller) => {\n        // Create SSE connection\n        const connection: SSEConnection = {\n          controller,\n          playerId: playerId || undefined,\n          isAdmin,\n          lastEventId,\n          connectedAt: Date.now()\n        };\n\n        this.sseConnections.add(connection);\n\n        // Send initial connection confirmation\n        this.sendSSEMessage(controller, {\n          type: \"connected\",\n          timestamp: Date.now(),\n          connectedClients: this.clients.size + this.sseConnections.size\n        }, \"connected\");\n\n        // Track presence for players\n        if (playerId && !isAdmin) {\n          // We need to get player details from the database since SSE doesn't send them\n          try {\n            const playerRow = await this.env.DB.prepare(\n              \"SELECT name, email FROM players WHERE id = ? AND room_code = ?\"\n            ).bind(playerId, this.code).first<any>();\n            \n            if (playerRow) {\n              this.present.set(playerId, {\n                name: playerRow.name || \"Player\",\n                email: playerRow.email || \"\",\n              });\n              // Broadcast presence update\n              this.broadcast({ type: \"presence\", count: this.present.size });\n            }\n          } catch (error) {\n            console.error(\"Error tracking presence for SSE player:\", error);\n          }\n        }\n\n        // Send current question if active\n        if (this.collecting && this.currentQuestionId) {\n          this.getCurrentQuestion().then(question => {\n            if (question) {\n              this.sendSSEMessage(controller, {\n                type: \"question\",\n                question: question,\n                deadline: this.currentStartMs + 25_000\n              }, \"question\");\n            }\n          }).catch(error => {\n            console.error(\"Error sending current question to SSE client:\", error);\n          });\n        }\n      },\n      cancel: () => {\n        connectionClosed = true;\n        // Find and remove the connection\n        for (const conn of this.sseConnections) {\n          if (conn.controller === arguments[0]) {\n            this.sseConnections.delete(conn);\n            if (conn.playerId && this.present.has(conn.playerId)) {\n              this.present.delete(conn.playerId);\n              this.broadcast({ type: \"presence\", count: this.present.size });\n            }\n            break;\n          }\n        }\n      }\n    });\n\n    return new Response(stream, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        \"Connection\": \"keep-alive\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Headers\": \"Cache-Control\",\n      },\n    });\n  }\n\n  // Answer Submission Handler\n  async handleAnswerSubmission(request: Request): Promise<Response> {\n    try {\n      const body = await request.json() as { \n        playerId: string; \n        optionId: string \n      };\n\n      // Enhanced rate limiting for answer submissions\n      if (!this.collecting || !this.currentQuestionId) {\n        return json({ type: \"error\", message: \"Answer window closed.\" }, { status: 400 });\n      }\n      \n      if (!body.playerId || !body.optionId) {\n        return json({ type: \"error\", message: \"Invalid answer data.\" }, { status: 400 });\n      }\n      \n      // Rate limiting: max 3 attempts per player per question\n      const attempts = this.answerAttempts.get(body.playerId) || 0;\n      if (attempts >= 3) {\n        return json({ type: \"error\", message: \"Too many answer attempts.\" }, { status: 429 });\n      }\n      \n      this.answerAttempts.set(body.playerId, attempts + 1);\n      \n      // Check for duplicate answers first (faster than database insert)\n      const already = await this.hasAnswered(this.currentQuestionId, body.playerId);\n      if (already) {\n        return json({ type: \"error\", message: \"You have already answered this question.\" }, { status: 409 });\n      }\n      \n      // Store answer with error handling\n      try {\n        await this.storeAnswer(this.currentQuestionId, body.playerId, body.optionId);\n        return json({ type: \"accepted\", at: Date.now() });\n      } catch (error) {\n        console.error(\"Answer storage failed:\", error);\n        return json({ type: \"error\", message: \"Failed to submit answer. Please try again.\" }, { status: 500 });\n      }\n    } catch (error) {\n      console.error(\"Answer submission error:\", error);\n      return json({ error: \"Invalid request\" }, { status: 400 });\n    }\n  }\n\n  broadcast(msg: any) {\n    // Send different messages to admins vs players\n    this.broadcastToAdmins(msg);\n    this.broadcastToPlayers(this.filterMessageForPlayers(msg));\n  }\n\n  // Filter sensitive information from messages sent to players\n  filterMessageForPlayers(msg: any): any {\n    if (msg.type === \"result\") {\n      // Players only get the correct answer ID, no leaderboard or scores\n      return {\n        type: \"result\",\n        questionId: msg.questionId,\n        correct_option_id: msg.correct_option_id\n      };\n    }\n    // All other message types are safe for players\n    return msg;\n  }\n\n  broadcastToAdmins(msg: any) {\n    const payload = JSON.stringify(msg);\n    let successCount = 0;\n    let failureCount = 0;\n    \n    // Broadcast to admin WebSocket clients\n    for (const c of this.clients) {\n      if (c.ws && c.isAdmin) {\n        try { \n          c.ws.send(payload);\n          successCount++;\n        } catch (error) {\n          failureCount++;\n          console.warn(\"Failed to send message to admin WebSocket client:\", error);\n          this.clients.delete(c);\n        }\n      }\n    }\n    \n    // Broadcast to admin SSE clients\n    for (const conn of this.sseConnections) {\n      if (conn.isAdmin) {\n        try {\n          this.sendSSEMessage(conn.controller, msg, msg.type || \"message\");\n          successCount++;\n        } catch (error) {\n          failureCount++;\n          console.warn(\"Failed to send SSE message to admin:\", error);\n        }\n      }\n    }\n    \n    if (failureCount > 0) {\n      console.log(`Admin Broadcast: ${successCount} sent, ${failureCount} failed`);\n    }\n  }\n\n  broadcastToPlayers(msg: any) {\n    const payload = JSON.stringify(msg);\n    let successCount = 0;\n    let failureCount = 0;\n    \n    // Broadcast to player WebSocket clients\n    for (const c of this.clients) {\n      if (c.ws && !c.isAdmin) {\n        try { \n          c.ws.send(payload);\n          successCount++;\n        } catch (error) {\n          failureCount++;\n          console.warn(\"Failed to send message to player WebSocket client:\", error);\n          this.clients.delete(c);\n        }\n      }\n    }\n    \n    // Broadcast to player SSE clients\n    for (const conn of this.sseConnections) {\n      if (!conn.isAdmin) {\n        try {\n          this.sendSSEMessage(conn.controller, msg, msg.type || \"message\");\n          successCount++;\n        } catch (error) {\n          failureCount++;\n          console.warn(\"Failed to send SSE message to player:\", error);\n        }\n      }\n    }\n    \n    if (failureCount > 0) {\n      console.log(`Player Broadcast: ${successCount} sent, ${failureCount} failed`);\n    }\n  }\n\n  // Send SSE message to a specific controller\n  sendSSEMessage(controller: ReadableStreamDefaultController, data: any, eventType: string = \"message\") {\n    const eventId = Date.now().toString();\n    const message = `id: ${eventId}\\nevent: ${eventType}\\ndata: ${JSON.stringify(data)}\\n\\n`;\n    \n    const encoder = new TextEncoder();\n    controller.enqueue(encoder.encode(message));\n  }\n\n  // Get current question for SSE connections\n  async getCurrentQuestion(): Promise<any> {\n    if (!this.currentQuestionId) {\n      return null;\n    }\n    \n    try {\n      const question = await this.loadQuestionById(this.currentQuestionId);\n      return question;\n    } catch (error) {\n      console.error(\"Error loading current question:\", error);\n      return {\n        id: this.currentQuestionId,\n        text: \"Loading question...\",\n        options: []\n      };\n    }\n  }\n\n  async loadQuestionById(questionId: string): Promise<QuizQuestion | null> {\n    try {\n      const questionRow = await this.env.DB.prepare(\n        \"SELECT q.id, q.text, q.correct_option_id, q.position FROM questions q WHERE q.id = ? AND q.room_code = ?\"\n      ).bind(questionId, this.code).first<any>();\n      \n      if (!questionRow) return null;\n      \n      const opts = await this.env.DB.prepare(\"SELECT id, text FROM options WHERE question_id = ?\")\n        .bind(questionId)\n        .all();\n\n      return {\n        id: questionRow.id,\n        text: questionRow.text,\n        correct_option_id: questionRow.correct_option_id,\n        options: (opts.results as any[]) || [],\n        position: questionRow.position,\n      };\n    } catch (error) {\n      console.error(\"Error loading question by ID:\", error);\n      return null;\n    }\n  }\n\n  cleanupStaleConnections() {\n    const staleClients = [];\n    for (const client of this.clients) {\n      if (client.ws && (client.ws.readyState === WebSocket.CLOSED || client.ws.readyState === WebSocket.CLOSING)) {\n        staleClients.push(client);\n      }\n    }\n    \n    for (const client of staleClients) {\n      this.clients.delete(client);\n      if (client.playerId && this.present.has(client.playerId)) {\n        this.present.delete(client.playerId);\n      }\n    }\n    \n    // Also cleanup stale SSE connections\n    const staleSSE = [];\n    for (const conn of this.sseConnections) {\n      try {\n        // Test if controller is still writable\n        this.sendSSEMessage(conn.controller, { type: \"ping\" }, \"ping\");\n      } catch (error) {\n        staleSSE.push(conn);\n      }\n    }\n    \n    for (const conn of staleSSE) {\n      this.sseConnections.delete(conn);\n      if (conn.playerId && this.present.has(conn.playerId)) {\n        this.present.delete(conn.playerId);\n      }\n    }\n    \n    if (staleClients.length > 0 || staleSSE.length > 0) {\n      console.log(`Cleaned up ${staleClients.length} stale WebSocket and ${staleSSE.length} SSE connections`);\n      this.broadcast({ type: \"presence\", count: this.present.size });\n    }\n  }\n\n  async persist() {\n    await this.state.storage.put(\"room\", {\n      code: this.code,\n      currentIndex: this.currentIndex,\n      currentQuestionId: this.currentQuestionId,\n      currentStartMs: this.currentStartMs,\n      collecting: this.collecting,\n    });\n  }\n\n  async loadNextQuestion(): Promise<QuizQuestion | null> {\n    const { results } = await this.env.DB.prepare(\n      \"SELECT q.id, q.text, q.correct_option_id FROM questions q WHERE q.room_code = ? ORDER BY position ASC\"\n    ).bind(this.code).all();\n\n    this.currentIndex += 1;\n    if (!results || this.currentIndex >= results.length) {\n      return null;\n    }\n\n    const row = results[this.currentIndex] as any;\n    const opts = await this.env.DB.prepare(\"SELECT id, text FROM options WHERE question_id = ?\")\n      .bind(row.id)\n      .all();\n\n    return {\n      id: row.id,\n      text: row.text,\n      correct_option_id: row.correct_option_id,\n      options: (opts.results as any[]) || [],\n      position: this.currentIndex,\n    };\n  }\n\n  async hasAnswered(qid: string, playerId: string): Promise<boolean> {\n    try {\n      // Optimized query using the new composite index\n      const result = await this.env.DB.prepare(\n        \"SELECT 1 FROM answers WHERE room_code = ? AND question_id = ? AND player_id = ? LIMIT 1\"\n      ).bind(this.code, qid, playerId).first();\n      return !!result;\n    } catch (error) {\n      console.error(\"Error checking if answered:\", error);\n      return false; // Fail safe - allow answer attempt\n    }\n  }\n\n  async storeAnswer(qid: string, playerId: string, optionId: string) {\n    const aid = crypto.randomUUID();\n    const timestamp = Date.now();\n    \n    // Retry logic for database operations under high load\n    const maxRetries = 3;\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        // Use INSERT OR IGNORE to handle race conditions gracefully\n        // The unique index will prevent duplicate answers\n        const result = await this.env.DB.prepare(\n          \"INSERT OR IGNORE INTO answers (id, room_code, question_id, player_id, option_id, first_flag, created_at) \" +\n          \"VALUES (?, ?, ?, ?, ?, ?, ?)\"\n        ).bind(aid, this.code, qid, playerId, optionId, 0, timestamp).run();\n        \n        // Check if the insert was successful using meta information\n        if (!result.success) {\n          throw new Error(\"Database insert failed\");\n        }\n        \n        return; // Success\n      } catch (error) {\n        console.error(`Answer storage attempt ${attempt} failed:`, error);\n        \n        if (attempt === maxRetries) {\n          throw new Error(\"Failed to submit answer after multiple attempts\");\n        }\n        \n        // Exponential backoff before retry\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 100));\n      }\n    }\n  }\n\n  // 25-second window ends here - heavily optimized for massive concurrent load\n  async alarm() {\n    if (!this.collecting || !this.currentQuestionId) return;\n\n    this.collecting = false;\n    const qid = this.currentQuestionId;\n    const processingStart = Date.now();\n\n    try {\n      // Parallel execution of critical queries for performance\n      const [qRow, ans] = await Promise.all([\n        // Get correct answer\n        this.env.DB.prepare(\n          \"SELECT correct_option_id FROM questions WHERE id = ? AND room_code = ?\"\n        ).bind(qid, this.code).first<any>(),\n        \n        // Get all answers with player info (optimized with indexes)\n        this.env.DB.prepare(\n          \"SELECT a.player_id, a.option_id, a.created_at, p.name, p.email \" +\n          \"FROM answers a JOIN players p ON a.player_id = p.id \" +\n          \"WHERE a.room_code = ? AND a.question_id = ? \" +\n          \"ORDER BY a.created_at ASC LIMIT 10000\" // Prevent runaway queries\n        ).bind(this.code, qid).all<any>()\n      ]);\n\n      // Accept both stored (prefixed) and raw fallback (e.g., 'o2') just in case\n      const storedCorrect: string | null = qRow?.correct_option_id ?? null;\n      const correctIds = new Set<string>();\n      if (storedCorrect) {\n        correctIds.add(storedCorrect);\n        if (!storedCorrect.includes(\":\")) correctIds.add(`${qid}:${storedCorrect}`);\n      }\n\n      const start = this.currentStartMs;\n      const allAnswers = ans.results || [];\n\n      // Filter correct answers (already sorted by created_at ASC)\n      const correct = allAnswers.filter((r: any) => correctIds.has(r.option_id));\n\n      // Build awards with enhanced performance tracking\n      const awards: Array<{ player_id: string; name: string; email: string; ms: number; points: number }> = [];\n      for (let i = 0; i < correct.length; i++) {\n        const r = correct[i];\n        const ms = r.created_at - start;\n        const points = i < RANK_POINTS.length ? RANK_POINTS[i] : MIN_POINTS_FOR_CORRECT;\n        awards.push({ player_id: r.player_id, name: r.name || \"Player\", email: r.email || \"\", ms, points });\n      }\n\n      // Ultra-optimized batch scoring update\n      if (awards.length > 0) {\n        // Group by points for efficient batch processing\n        const pointGroups = new Map<number, string[]>();\n        for (const a of awards) {\n          if (!pointGroups.has(a.points)) {\n            pointGroups.set(a.points, []);\n          }\n          pointGroups.get(a.points)!.push(a.player_id);\n        }\n\n        // Execute all score updates in parallel with retry logic\n        const updatePromises = Array.from(pointGroups.entries()).map(async ([points, playerIds]) => {\n          const placeholders = playerIds.map(() => '?').join(',');\n          const maxRetries = 3;\n          \n          for (let attempt = 1; attempt <= maxRetries; attempt++) {\n            try {\n              await this.env.DB.prepare(\n                `UPDATE players SET score = score + ? WHERE id IN (${placeholders})`\n              ).bind(points, ...playerIds).run();\n              break; // Success\n            } catch (error) {\n              console.error(`Score update attempt ${attempt} failed:`, error);\n              if (attempt === maxRetries) {\n                throw error;\n              }\n              await new Promise(resolve => setTimeout(resolve, attempt * 100));\n            }\n          }\n        });\n\n        await Promise.all(updatePromises);\n      }\n\n      // Generate optimized leaderboard\n      const leaderboard = awards.slice(0, 50).map((a, idx) => ({ // Limit to top 50 for performance\n        rank: idx + 1,\n        name: a.name,\n        email: a.email,\n        ms: a.ms,\n        points: a.points,\n      }));\n\n      const processingTime = Date.now() - processingStart;\n\n      // Enhanced broadcast with performance metrics\n      this.broadcast({\n        type: \"result\",\n        questionId: qid,\n        correct_option_id: storedCorrect,\n        leaderboard,\n        stats: {\n          totalAnswers: allAnswers.length,\n          correctAnswers: correct.length,\n          processingTimeMs: processingTime,\n          connectedClients: this.clients.size + this.sseConnections.size\n        }\n      });\n\n      await this.persist();\n      \n      // Performance monitoring\n      if (processingTime > 1000) {\n        console.warn(`Slow alarm processing: ${processingTime}ms for ${allAnswers.length} answers`);\n      }\n      \n    } catch (error) {\n      console.error(\"Critical error in alarm processing:\", error);\n      // Emergency broadcast to clients\n      this.broadcast({\n        type: \"error\",\n        message: \"Error processing question results. Please refresh if issues persist.\",\n        questionId: qid\n      });\n    }\n  }\n}\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"E:\\\\Projects\\\\cloudflare-realtime-quiz\\\\src\\\\index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"C:\\\\Users\\\\palsh\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"C:\\\\Users\\\\palsh\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"E:\\\\Projects\\\\cloudflare-realtime-quiz\\\\src\\\\index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"E:\\\\Projects\\\\cloudflare-realtime-quiz\\\\.wrangler\\\\tmp\\\\bundle-nOvJ93\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"C:\\\\Users\\\\palsh\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"E:\\\\Projects\\\\cloudflare-realtime-quiz\\\\.wrangler\\\\tmp\\\\bundle-nOvJ93\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"E:\\\\Projects\\\\cloudflare-realtime-quiz\\\\.wrangler\\\\tmp\\\\bundle-nOvJ93\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
